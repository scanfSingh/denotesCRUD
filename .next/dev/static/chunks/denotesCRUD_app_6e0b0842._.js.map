{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsingh/Desktop/GitHub/denotesCRUD/app/actions.ts"],"sourcesContent":["\"use server\";\n\nimport client from \"@/lib/mongodb\";\nimport { ObjectId } from \"mongodb\";\nimport { revalidatePath } from \"next/cache\";\n\nexport interface Task {\n  _id?: string;\n  title: string;\n  description: string;\n  completed: boolean;\n  createdAt?: Date;\n  updatedAt?: Date;\n}\n\nexport interface Topic {\n  _id?: string;\n  title: string;\n  description: string;\n  linkedTopics: string[]; // Array of topic IDs this topic is linked to\n  parentTopicId?: string; // Optional parent for hierarchical display\n  createdAt?: Date;\n  updatedAt?: Date;\n}\n\nexport async function testDatabaseConnection() {\n  let isConnected = false;\n  try {\n    const mongoClient = await client.connect();\n    // Send a ping to confirm a successful connection\n    await mongoClient.db(\"admin\").command({ ping: 1 });\n    console.log(\n      \"Pinged your deployment. You successfully connected to MongoDB!\",\n    ); // because this is a server action, the console.log will be outputted to your terminal not in the browser\n    return !isConnected;\n  } catch (e) {\n    console.error(e);\n    return isConnected;\n  }\n}\n\n// CREATE - Add a new task\nexport async function createTask(formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const newTask = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      completed: false,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    const result = await collection.insertOne(newTask);\n    revalidatePath(\"/crud\");\n    return { success: true, id: result.insertedId.toString() };\n  } catch (error) {\n    console.error(\"Error creating task:\", error);\n    return { success: false, error: \"Failed to create task\" };\n  }\n}\n\n// READ - Get all tasks\nexport async function getTasks(): Promise<Task[]> {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const tasks = await collection\n      .find({})\n      .sort({ createdAt: -1 })\n      .toArray();\n\n    return tasks.map((task) => ({\n      _id: task._id.toString(),\n      title: task.title,\n      description: task.description,\n      completed: task.completed,\n      createdAt: task.createdAt,\n      updatedAt: task.updatedAt,\n    }));\n  } catch (error) {\n    console.error(\"Error fetching tasks:\", error);\n    return [];\n  }\n}\n\n// UPDATE - Update a task\nexport async function updateTask(taskId: string, formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n    const completed = formData.get(\"completed\") === \"true\";\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const updateData: any = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      completed,\n      updatedAt: new Date(),\n    };\n\n    const result = await collection.updateOne(\n      { _id: new ObjectId(taskId) },\n      { $set: updateData }\n    );\n\n    if (result.matchedCount === 0) {\n      return { success: false, error: \"Task not found\" };\n    }\n\n    revalidatePath(\"/crud\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error updating task:\", error);\n    return { success: false, error: \"Failed to update task\" };\n  }\n}\n\n// DELETE - Delete a task\nexport async function deleteTask(taskId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const result = await collection.deleteOne({ _id: new ObjectId(taskId) });\n\n    if (result.deletedCount === 0) {\n      return { success: false, error: \"Task not found\" };\n    }\n\n    revalidatePath(\"/crud\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting task:\", error);\n    return { success: false, error: \"Failed to delete task\" };\n  }\n}\n\n// TOGGLE - Toggle task completion status\nexport async function toggleTask(taskId: string, completed: boolean) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const result = await collection.updateOne(\n      { _id: new ObjectId(taskId) },\n      { $set: { completed: !completed, updatedAt: new Date() } }\n    );\n\n    if (result.matchedCount === 0) {\n      return { success: false, error: \"Task not found\" };\n    }\n\n    revalidatePath(\"/crud\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error toggling task:\", error);\n    return { success: false, error: \"Failed to toggle task\" };\n  }\n}\n\n// ========== TOPIC CRUD OPERATIONS ==========\n\n// CREATE - Add a new topic\nexport async function createTopic(formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n    const parentTopicId = formData.get(\"parentTopicId\") as string;\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const newTopic: any = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      linkedTopics: [],\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    if (parentTopicId && parentTopicId.trim() !== \"\") {\n      newTopic.parentTopicId = parentTopicId.trim();\n    }\n\n    const result = await collection.insertOne(newTopic);\n    revalidatePath(\"/topics\");\n    return { success: true, id: result.insertedId.toString() };\n  } catch (error) {\n    console.error(\"Error creating topic:\", error);\n    return { success: false, error: \"Failed to create topic\" };\n  }\n}\n\n// READ - Get all topics with full details\nexport async function getTopics(): Promise<Topic[]> {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const topics = await collection\n      .find({})\n      .sort({ createdAt: -1 })\n      .toArray();\n\n    return topics.map((topic) => ({\n      _id: topic._id.toString(),\n      title: topic.title,\n      description: topic.description || \"\",\n      linkedTopics: (topic.linkedTopics || []).map((id: ObjectId) =>\n        id.toString()\n      ),\n      parentTopicId: topic.parentTopicId?.toString(),\n      createdAt: topic.createdAt,\n      updatedAt: topic.updatedAt,\n    }));\n  } catch (error) {\n    console.error(\"Error fetching topics:\", error);\n    return [];\n  }\n}\n\n// READ - Get a single topic by ID\nexport async function getTopic(topicId: string): Promise<Topic | null> {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const topic = await collection.findOne({ _id: new ObjectId(topicId) });\n\n    if (!topic) {\n      return null;\n    }\n\n    return {\n      _id: topic._id.toString(),\n      title: topic.title,\n      description: topic.description || \"\",\n      linkedTopics: (topic.linkedTopics || []).map((id: ObjectId) =>\n        id.toString()\n      ),\n      parentTopicId: topic.parentTopicId?.toString(),\n      createdAt: topic.createdAt,\n      updatedAt: topic.updatedAt,\n    };\n  } catch (error) {\n    console.error(\"Error fetching topic:\", error);\n    return null;\n  }\n}\n\n// UPDATE - Update a topic\nexport async function updateTopic(topicId: string, formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n    const parentTopicId = formData.get(\"parentTopicId\") as string;\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const updateData: any = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      updatedAt: new Date(),\n    };\n\n    if (parentTopicId && parentTopicId.trim() !== \"\" && parentTopicId !== topicId) {\n      updateData.parentTopicId = parentTopicId.trim();\n    } else if (parentTopicId === \"\") {\n      updateData.parentTopicId = null;\n    }\n\n    const result = await collection.updateOne(\n      { _id: new ObjectId(topicId) },\n      { $set: updateData }\n    );\n\n    if (result.matchedCount === 0) {\n      return { success: false, error: \"Topic not found\" };\n    }\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error updating topic:\", error);\n    return { success: false, error: \"Failed to update topic\" };\n  }\n}\n\n// DELETE - Delete a topic\nexport async function deleteTopic(topicId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    // Remove topic from linkedTopics arrays of other topics\n    await collection.updateMany(\n      { linkedTopics: new ObjectId(topicId) },\n      { $pull: { linkedTopics: new ObjectId(topicId) } }\n    );\n\n    // Remove parentTopicId references\n    await collection.updateMany(\n      { parentTopicId: new ObjectId(topicId) },\n      { $unset: { parentTopicId: \"\" } }\n    );\n\n    const result = await collection.deleteOne({ _id: new ObjectId(topicId) });\n\n    if (result.deletedCount === 0) {\n      return { success: false, error: \"Topic not found\" };\n    }\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting topic:\", error);\n    return { success: false, error: \"Failed to delete topic\" };\n  }\n}\n\n// LINK - Link a topic to another topic\nexport async function linkTopics(topicId: string, linkedTopicId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    if (topicId === linkedTopicId) {\n      return { success: false, error: \"A topic cannot be linked to itself\" };\n    }\n\n    // Add bidirectional link\n    await collection.updateOne(\n      { _id: new ObjectId(topicId) },\n      { $addToSet: { linkedTopics: new ObjectId(linkedTopicId) } }\n    );\n\n    await collection.updateOne(\n      { _id: new ObjectId(linkedTopicId) },\n      { $addToSet: { linkedTopics: new ObjectId(topicId) } }\n    );\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error linking topics:\", error);\n    return { success: false, error: \"Failed to link topics\" };\n  }\n}\n\n// UNLINK - Unlink a topic from another topic\nexport async function unlinkTopics(topicId: string, linkedTopicId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    // Remove bidirectional link\n    await collection.updateOne(\n      { _id: new ObjectId(topicId) },\n      { $pull: { linkedTopics: new ObjectId(linkedTopicId) } }\n    );\n\n    await collection.updateOne(\n      { _id: new ObjectId(linkedTopicId) },\n      { $pull: { linkedTopics: new ObjectId(topicId) } }\n    );\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error unlinking topics:\", error);\n    return { success: false, error: \"Failed to unlink topics\" };\n  }\n}\n"],"names":[],"mappings":";;;;;;;IAyLsB,cAAA,WAAA,GAAA,IAAA,iQAAA,EAAA,8CAAA,sPAAA,EAAA,KAAA,GAAA,4PAAA,EAAA","debugId":null}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsingh/Desktop/GitHub/denotesCRUD/app/actions.ts"],"sourcesContent":["\"use server\";\n\nimport client from \"@/lib/mongodb\";\nimport { ObjectId } from \"mongodb\";\nimport { revalidatePath } from \"next/cache\";\n\nexport interface Task {\n  _id?: string;\n  title: string;\n  description: string;\n  completed: boolean;\n  createdAt?: Date;\n  updatedAt?: Date;\n}\n\nexport interface Topic {\n  _id?: string;\n  title: string;\n  description: string;\n  linkedTopics: string[]; // Array of topic IDs this topic is linked to\n  parentTopicId?: string; // Optional parent for hierarchical display\n  createdAt?: Date;\n  updatedAt?: Date;\n}\n\nexport async function testDatabaseConnection() {\n  let isConnected = false;\n  try {\n    const mongoClient = await client.connect();\n    // Send a ping to confirm a successful connection\n    await mongoClient.db(\"admin\").command({ ping: 1 });\n    console.log(\n      \"Pinged your deployment. You successfully connected to MongoDB!\",\n    ); // because this is a server action, the console.log will be outputted to your terminal not in the browser\n    return !isConnected;\n  } catch (e) {\n    console.error(e);\n    return isConnected;\n  }\n}\n\n// CREATE - Add a new task\nexport async function createTask(formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const newTask = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      completed: false,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    const result = await collection.insertOne(newTask);\n    revalidatePath(\"/crud\");\n    return { success: true, id: result.insertedId.toString() };\n  } catch (error) {\n    console.error(\"Error creating task:\", error);\n    return { success: false, error: \"Failed to create task\" };\n  }\n}\n\n// READ - Get all tasks\nexport async function getTasks(): Promise<Task[]> {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const tasks = await collection\n      .find({})\n      .sort({ createdAt: -1 })\n      .toArray();\n\n    return tasks.map((task) => ({\n      _id: task._id.toString(),\n      title: task.title,\n      description: task.description,\n      completed: task.completed,\n      createdAt: task.createdAt,\n      updatedAt: task.updatedAt,\n    }));\n  } catch (error) {\n    console.error(\"Error fetching tasks:\", error);\n    return [];\n  }\n}\n\n// UPDATE - Update a task\nexport async function updateTask(taskId: string, formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n    const completed = formData.get(\"completed\") === \"true\";\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const updateData: any = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      completed,\n      updatedAt: new Date(),\n    };\n\n    const result = await collection.updateOne(\n      { _id: new ObjectId(taskId) },\n      { $set: updateData }\n    );\n\n    if (result.matchedCount === 0) {\n      return { success: false, error: \"Task not found\" };\n    }\n\n    revalidatePath(\"/crud\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error updating task:\", error);\n    return { success: false, error: \"Failed to update task\" };\n  }\n}\n\n// DELETE - Delete a task\nexport async function deleteTask(taskId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const result = await collection.deleteOne({ _id: new ObjectId(taskId) });\n\n    if (result.deletedCount === 0) {\n      return { success: false, error: \"Task not found\" };\n    }\n\n    revalidatePath(\"/crud\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting task:\", error);\n    return { success: false, error: \"Failed to delete task\" };\n  }\n}\n\n// TOGGLE - Toggle task completion status\nexport async function toggleTask(taskId: string, completed: boolean) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const result = await collection.updateOne(\n      { _id: new ObjectId(taskId) },\n      { $set: { completed: !completed, updatedAt: new Date() } }\n    );\n\n    if (result.matchedCount === 0) {\n      return { success: false, error: \"Task not found\" };\n    }\n\n    revalidatePath(\"/crud\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error toggling task:\", error);\n    return { success: false, error: \"Failed to toggle task\" };\n  }\n}\n\n// ========== TOPIC CRUD OPERATIONS ==========\n\n// CREATE - Add a new topic\nexport async function createTopic(formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n    const parentTopicId = formData.get(\"parentTopicId\") as string;\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const newTopic: any = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      linkedTopics: [],\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    if (parentTopicId && parentTopicId.trim() !== \"\") {\n      newTopic.parentTopicId = parentTopicId.trim();\n    }\n\n    const result = await collection.insertOne(newTopic);\n    revalidatePath(\"/topics\");\n    return { success: true, id: result.insertedId.toString() };\n  } catch (error) {\n    console.error(\"Error creating topic:\", error);\n    return { success: false, error: \"Failed to create topic\" };\n  }\n}\n\n// READ - Get all topics with full details\nexport async function getTopics(): Promise<Topic[]> {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const topics = await collection\n      .find({})\n      .sort({ createdAt: -1 })\n      .toArray();\n\n    return topics.map((topic) => ({\n      _id: topic._id.toString(),\n      title: topic.title,\n      description: topic.description || \"\",\n      linkedTopics: (topic.linkedTopics || []).map((id: ObjectId) =>\n        id.toString()\n      ),\n      parentTopicId: topic.parentTopicId?.toString(),\n      createdAt: topic.createdAt,\n      updatedAt: topic.updatedAt,\n    }));\n  } catch (error) {\n    console.error(\"Error fetching topics:\", error);\n    return [];\n  }\n}\n\n// READ - Get a single topic by ID\nexport async function getTopic(topicId: string): Promise<Topic | null> {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const topic = await collection.findOne({ _id: new ObjectId(topicId) });\n\n    if (!topic) {\n      return null;\n    }\n\n    return {\n      _id: topic._id.toString(),\n      title: topic.title,\n      description: topic.description || \"\",\n      linkedTopics: (topic.linkedTopics || []).map((id: ObjectId) =>\n        id.toString()\n      ),\n      parentTopicId: topic.parentTopicId?.toString(),\n      createdAt: topic.createdAt,\n      updatedAt: topic.updatedAt,\n    };\n  } catch (error) {\n    console.error(\"Error fetching topic:\", error);\n    return null;\n  }\n}\n\n// UPDATE - Update a topic\nexport async function updateTopic(topicId: string, formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n    const parentTopicId = formData.get(\"parentTopicId\") as string;\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const updateData: any = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      updatedAt: new Date(),\n    };\n\n    if (parentTopicId && parentTopicId.trim() !== \"\" && parentTopicId !== topicId) {\n      updateData.parentTopicId = parentTopicId.trim();\n    } else if (parentTopicId === \"\") {\n      updateData.parentTopicId = null;\n    }\n\n    const result = await collection.updateOne(\n      { _id: new ObjectId(topicId) },\n      { $set: updateData }\n    );\n\n    if (result.matchedCount === 0) {\n      return { success: false, error: \"Topic not found\" };\n    }\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error updating topic:\", error);\n    return { success: false, error: \"Failed to update topic\" };\n  }\n}\n\n// DELETE - Delete a topic\nexport async function deleteTopic(topicId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    // Remove topic from linkedTopics arrays of other topics\n    await collection.updateMany(\n      { linkedTopics: new ObjectId(topicId) },\n      { $pull: { linkedTopics: new ObjectId(topicId) } }\n    );\n\n    // Remove parentTopicId references\n    await collection.updateMany(\n      { parentTopicId: new ObjectId(topicId) },\n      { $unset: { parentTopicId: \"\" } }\n    );\n\n    const result = await collection.deleteOne({ _id: new ObjectId(topicId) });\n\n    if (result.deletedCount === 0) {\n      return { success: false, error: \"Topic not found\" };\n    }\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting topic:\", error);\n    return { success: false, error: \"Failed to delete topic\" };\n  }\n}\n\n// LINK - Link a topic to another topic\nexport async function linkTopics(topicId: string, linkedTopicId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    if (topicId === linkedTopicId) {\n      return { success: false, error: \"A topic cannot be linked to itself\" };\n    }\n\n    // Add bidirectional link\n    await collection.updateOne(\n      { _id: new ObjectId(topicId) },\n      { $addToSet: { linkedTopics: new ObjectId(linkedTopicId) } }\n    );\n\n    await collection.updateOne(\n      { _id: new ObjectId(linkedTopicId) },\n      { $addToSet: { linkedTopics: new ObjectId(topicId) } }\n    );\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error linking topics:\", error);\n    return { success: false, error: \"Failed to link topics\" };\n  }\n}\n\n// UNLINK - Unlink a topic from another topic\nexport async function unlinkTopics(topicId: string, linkedTopicId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    // Remove bidirectional link\n    await collection.updateOne(\n      { _id: new ObjectId(topicId) },\n      { $pull: { linkedTopics: new ObjectId(linkedTopicId) } }\n    );\n\n    await collection.updateOne(\n      { _id: new ObjectId(linkedTopicId) },\n      { $pull: { linkedTopics: new ObjectId(topicId) } }\n    );\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error unlinking topics:\", error);\n    return { success: false, error: \"Failed to unlink topics\" };\n  }\n}\n"],"names":[],"mappings":";;;;;;;IA6NsB,YAAA,WAAA,GAAA,IAAA,iQAAA,EAAA,8CAAA,sPAAA,EAAA,KAAA,GAAA,4PAAA,EAAA","debugId":null}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsingh/Desktop/GitHub/denotesCRUD/app/actions.ts"],"sourcesContent":["\"use server\";\n\nimport client from \"@/lib/mongodb\";\nimport { ObjectId } from \"mongodb\";\nimport { revalidatePath } from \"next/cache\";\n\nexport interface Task {\n  _id?: string;\n  title: string;\n  description: string;\n  completed: boolean;\n  createdAt?: Date;\n  updatedAt?: Date;\n}\n\nexport interface Topic {\n  _id?: string;\n  title: string;\n  description: string;\n  linkedTopics: string[]; // Array of topic IDs this topic is linked to\n  parentTopicId?: string; // Optional parent for hierarchical display\n  createdAt?: Date;\n  updatedAt?: Date;\n}\n\nexport async function testDatabaseConnection() {\n  let isConnected = false;\n  try {\n    const mongoClient = await client.connect();\n    // Send a ping to confirm a successful connection\n    await mongoClient.db(\"admin\").command({ ping: 1 });\n    console.log(\n      \"Pinged your deployment. You successfully connected to MongoDB!\",\n    ); // because this is a server action, the console.log will be outputted to your terminal not in the browser\n    return !isConnected;\n  } catch (e) {\n    console.error(e);\n    return isConnected;\n  }\n}\n\n// CREATE - Add a new task\nexport async function createTask(formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const newTask = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      completed: false,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    const result = await collection.insertOne(newTask);\n    revalidatePath(\"/crud\");\n    return { success: true, id: result.insertedId.toString() };\n  } catch (error) {\n    console.error(\"Error creating task:\", error);\n    return { success: false, error: \"Failed to create task\" };\n  }\n}\n\n// READ - Get all tasks\nexport async function getTasks(): Promise<Task[]> {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const tasks = await collection\n      .find({})\n      .sort({ createdAt: -1 })\n      .toArray();\n\n    return tasks.map((task) => ({\n      _id: task._id.toString(),\n      title: task.title,\n      description: task.description,\n      completed: task.completed,\n      createdAt: task.createdAt,\n      updatedAt: task.updatedAt,\n    }));\n  } catch (error) {\n    console.error(\"Error fetching tasks:\", error);\n    return [];\n  }\n}\n\n// UPDATE - Update a task\nexport async function updateTask(taskId: string, formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n    const completed = formData.get(\"completed\") === \"true\";\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const updateData: any = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      completed,\n      updatedAt: new Date(),\n    };\n\n    const result = await collection.updateOne(\n      { _id: new ObjectId(taskId) },\n      { $set: updateData }\n    );\n\n    if (result.matchedCount === 0) {\n      return { success: false, error: \"Task not found\" };\n    }\n\n    revalidatePath(\"/crud\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error updating task:\", error);\n    return { success: false, error: \"Failed to update task\" };\n  }\n}\n\n// DELETE - Delete a task\nexport async function deleteTask(taskId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const result = await collection.deleteOne({ _id: new ObjectId(taskId) });\n\n    if (result.deletedCount === 0) {\n      return { success: false, error: \"Task not found\" };\n    }\n\n    revalidatePath(\"/crud\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting task:\", error);\n    return { success: false, error: \"Failed to delete task\" };\n  }\n}\n\n// TOGGLE - Toggle task completion status\nexport async function toggleTask(taskId: string, completed: boolean) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const result = await collection.updateOne(\n      { _id: new ObjectId(taskId) },\n      { $set: { completed: !completed, updatedAt: new Date() } }\n    );\n\n    if (result.matchedCount === 0) {\n      return { success: false, error: \"Task not found\" };\n    }\n\n    revalidatePath(\"/crud\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error toggling task:\", error);\n    return { success: false, error: \"Failed to toggle task\" };\n  }\n}\n\n// ========== TOPIC CRUD OPERATIONS ==========\n\n// CREATE - Add a new topic\nexport async function createTopic(formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n    const parentTopicId = formData.get(\"parentTopicId\") as string;\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const newTopic: any = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      linkedTopics: [],\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    if (parentTopicId && parentTopicId.trim() !== \"\") {\n      newTopic.parentTopicId = parentTopicId.trim();\n    }\n\n    const result = await collection.insertOne(newTopic);\n    revalidatePath(\"/topics\");\n    return { success: true, id: result.insertedId.toString() };\n  } catch (error) {\n    console.error(\"Error creating topic:\", error);\n    return { success: false, error: \"Failed to create topic\" };\n  }\n}\n\n// READ - Get all topics with full details\nexport async function getTopics(): Promise<Topic[]> {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const topics = await collection\n      .find({})\n      .sort({ createdAt: -1 })\n      .toArray();\n\n    return topics.map((topic) => ({\n      _id: topic._id.toString(),\n      title: topic.title,\n      description: topic.description || \"\",\n      linkedTopics: (topic.linkedTopics || []).map((id: ObjectId) =>\n        id.toString()\n      ),\n      parentTopicId: topic.parentTopicId?.toString(),\n      createdAt: topic.createdAt,\n      updatedAt: topic.updatedAt,\n    }));\n  } catch (error) {\n    console.error(\"Error fetching topics:\", error);\n    return [];\n  }\n}\n\n// READ - Get a single topic by ID\nexport async function getTopic(topicId: string): Promise<Topic | null> {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const topic = await collection.findOne({ _id: new ObjectId(topicId) });\n\n    if (!topic) {\n      return null;\n    }\n\n    return {\n      _id: topic._id.toString(),\n      title: topic.title,\n      description: topic.description || \"\",\n      linkedTopics: (topic.linkedTopics || []).map((id: ObjectId) =>\n        id.toString()\n      ),\n      parentTopicId: topic.parentTopicId?.toString(),\n      createdAt: topic.createdAt,\n      updatedAt: topic.updatedAt,\n    };\n  } catch (error) {\n    console.error(\"Error fetching topic:\", error);\n    return null;\n  }\n}\n\n// UPDATE - Update a topic\nexport async function updateTopic(topicId: string, formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n    const parentTopicId = formData.get(\"parentTopicId\") as string;\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const updateData: any = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      updatedAt: new Date(),\n    };\n\n    if (parentTopicId && parentTopicId.trim() !== \"\" && parentTopicId !== topicId) {\n      updateData.parentTopicId = parentTopicId.trim();\n    } else if (parentTopicId === \"\") {\n      updateData.parentTopicId = null;\n    }\n\n    const result = await collection.updateOne(\n      { _id: new ObjectId(topicId) },\n      { $set: updateData }\n    );\n\n    if (result.matchedCount === 0) {\n      return { success: false, error: \"Topic not found\" };\n    }\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error updating topic:\", error);\n    return { success: false, error: \"Failed to update topic\" };\n  }\n}\n\n// DELETE - Delete a topic\nexport async function deleteTopic(topicId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    // Remove topic from linkedTopics arrays of other topics\n    await collection.updateMany(\n      { linkedTopics: new ObjectId(topicId) },\n      { $pull: { linkedTopics: new ObjectId(topicId) } }\n    );\n\n    // Remove parentTopicId references\n    await collection.updateMany(\n      { parentTopicId: new ObjectId(topicId) },\n      { $unset: { parentTopicId: \"\" } }\n    );\n\n    const result = await collection.deleteOne({ _id: new ObjectId(topicId) });\n\n    if (result.deletedCount === 0) {\n      return { success: false, error: \"Topic not found\" };\n    }\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting topic:\", error);\n    return { success: false, error: \"Failed to delete topic\" };\n  }\n}\n\n// LINK - Link a topic to another topic\nexport async function linkTopics(topicId: string, linkedTopicId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    if (topicId === linkedTopicId) {\n      return { success: false, error: \"A topic cannot be linked to itself\" };\n    }\n\n    // Add bidirectional link\n    await collection.updateOne(\n      { _id: new ObjectId(topicId) },\n      { $addToSet: { linkedTopics: new ObjectId(linkedTopicId) } }\n    );\n\n    await collection.updateOne(\n      { _id: new ObjectId(linkedTopicId) },\n      { $addToSet: { linkedTopics: new ObjectId(topicId) } }\n    );\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error linking topics:\", error);\n    return { success: false, error: \"Failed to link topics\" };\n  }\n}\n\n// UNLINK - Unlink a topic from another topic\nexport async function unlinkTopics(topicId: string, linkedTopicId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    // Remove bidirectional link\n    await collection.updateOne(\n      { _id: new ObjectId(topicId) },\n      { $pull: { linkedTopics: new ObjectId(linkedTopicId) } }\n    );\n\n    await collection.updateOne(\n      { _id: new ObjectId(linkedTopicId) },\n      { $pull: { linkedTopics: new ObjectId(topicId) } }\n    );\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error unlinking topics:\", error);\n    return { success: false, error: \"Failed to unlink topics\" };\n  }\n}\n"],"names":[],"mappings":";;;;;;;IA0PsB,WAAA,WAAA,GAAA,IAAA,iQAAA,EAAA,8CAAA,sPAAA,EAAA,KAAA,GAAA,4PAAA,EAAA","debugId":null}},
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsingh/Desktop/GitHub/denotesCRUD/app/actions.ts"],"sourcesContent":["\"use server\";\n\nimport client from \"@/lib/mongodb\";\nimport { ObjectId } from \"mongodb\";\nimport { revalidatePath } from \"next/cache\";\n\nexport interface Task {\n  _id?: string;\n  title: string;\n  description: string;\n  completed: boolean;\n  createdAt?: Date;\n  updatedAt?: Date;\n}\n\nexport interface Topic {\n  _id?: string;\n  title: string;\n  description: string;\n  linkedTopics: string[]; // Array of topic IDs this topic is linked to\n  parentTopicId?: string; // Optional parent for hierarchical display\n  createdAt?: Date;\n  updatedAt?: Date;\n}\n\nexport async function testDatabaseConnection() {\n  let isConnected = false;\n  try {\n    const mongoClient = await client.connect();\n    // Send a ping to confirm a successful connection\n    await mongoClient.db(\"admin\").command({ ping: 1 });\n    console.log(\n      \"Pinged your deployment. You successfully connected to MongoDB!\",\n    ); // because this is a server action, the console.log will be outputted to your terminal not in the browser\n    return !isConnected;\n  } catch (e) {\n    console.error(e);\n    return isConnected;\n  }\n}\n\n// CREATE - Add a new task\nexport async function createTask(formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const newTask = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      completed: false,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    const result = await collection.insertOne(newTask);\n    revalidatePath(\"/crud\");\n    return { success: true, id: result.insertedId.toString() };\n  } catch (error) {\n    console.error(\"Error creating task:\", error);\n    return { success: false, error: \"Failed to create task\" };\n  }\n}\n\n// READ - Get all tasks\nexport async function getTasks(): Promise<Task[]> {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const tasks = await collection\n      .find({})\n      .sort({ createdAt: -1 })\n      .toArray();\n\n    return tasks.map((task) => ({\n      _id: task._id.toString(),\n      title: task.title,\n      description: task.description,\n      completed: task.completed,\n      createdAt: task.createdAt,\n      updatedAt: task.updatedAt,\n    }));\n  } catch (error) {\n    console.error(\"Error fetching tasks:\", error);\n    return [];\n  }\n}\n\n// UPDATE - Update a task\nexport async function updateTask(taskId: string, formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n    const completed = formData.get(\"completed\") === \"true\";\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const updateData: any = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      completed,\n      updatedAt: new Date(),\n    };\n\n    const result = await collection.updateOne(\n      { _id: new ObjectId(taskId) },\n      { $set: updateData }\n    );\n\n    if (result.matchedCount === 0) {\n      return { success: false, error: \"Task not found\" };\n    }\n\n    revalidatePath(\"/crud\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error updating task:\", error);\n    return { success: false, error: \"Failed to update task\" };\n  }\n}\n\n// DELETE - Delete a task\nexport async function deleteTask(taskId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const result = await collection.deleteOne({ _id: new ObjectId(taskId) });\n\n    if (result.deletedCount === 0) {\n      return { success: false, error: \"Task not found\" };\n    }\n\n    revalidatePath(\"/crud\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting task:\", error);\n    return { success: false, error: \"Failed to delete task\" };\n  }\n}\n\n// TOGGLE - Toggle task completion status\nexport async function toggleTask(taskId: string, completed: boolean) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const result = await collection.updateOne(\n      { _id: new ObjectId(taskId) },\n      { $set: { completed: !completed, updatedAt: new Date() } }\n    );\n\n    if (result.matchedCount === 0) {\n      return { success: false, error: \"Task not found\" };\n    }\n\n    revalidatePath(\"/crud\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error toggling task:\", error);\n    return { success: false, error: \"Failed to toggle task\" };\n  }\n}\n\n// ========== TOPIC CRUD OPERATIONS ==========\n\n// CREATE - Add a new topic\nexport async function createTopic(formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n    const parentTopicId = formData.get(\"parentTopicId\") as string;\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const newTopic: any = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      linkedTopics: [],\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    if (parentTopicId && parentTopicId.trim() !== \"\") {\n      newTopic.parentTopicId = parentTopicId.trim();\n    }\n\n    const result = await collection.insertOne(newTopic);\n    revalidatePath(\"/topics\");\n    return { success: true, id: result.insertedId.toString() };\n  } catch (error) {\n    console.error(\"Error creating topic:\", error);\n    return { success: false, error: \"Failed to create topic\" };\n  }\n}\n\n// READ - Get all topics with full details\nexport async function getTopics(): Promise<Topic[]> {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const topics = await collection\n      .find({})\n      .sort({ createdAt: -1 })\n      .toArray();\n\n    return topics.map((topic) => ({\n      _id: topic._id.toString(),\n      title: topic.title,\n      description: topic.description || \"\",\n      linkedTopics: (topic.linkedTopics || []).map((id: ObjectId) =>\n        id.toString()\n      ),\n      parentTopicId: topic.parentTopicId?.toString(),\n      createdAt: topic.createdAt,\n      updatedAt: topic.updatedAt,\n    }));\n  } catch (error) {\n    console.error(\"Error fetching topics:\", error);\n    return [];\n  }\n}\n\n// READ - Get a single topic by ID\nexport async function getTopic(topicId: string): Promise<Topic | null> {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const topic = await collection.findOne({ _id: new ObjectId(topicId) });\n\n    if (!topic) {\n      return null;\n    }\n\n    return {\n      _id: topic._id.toString(),\n      title: topic.title,\n      description: topic.description || \"\",\n      linkedTopics: (topic.linkedTopics || []).map((id: ObjectId) =>\n        id.toString()\n      ),\n      parentTopicId: topic.parentTopicId?.toString(),\n      createdAt: topic.createdAt,\n      updatedAt: topic.updatedAt,\n    };\n  } catch (error) {\n    console.error(\"Error fetching topic:\", error);\n    return null;\n  }\n}\n\n// UPDATE - Update a topic\nexport async function updateTopic(topicId: string, formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n    const parentTopicId = formData.get(\"parentTopicId\") as string;\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const updateData: any = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      updatedAt: new Date(),\n    };\n\n    if (parentTopicId && parentTopicId.trim() !== \"\" && parentTopicId !== topicId) {\n      updateData.parentTopicId = parentTopicId.trim();\n    } else if (parentTopicId === \"\") {\n      updateData.parentTopicId = null;\n    }\n\n    const result = await collection.updateOne(\n      { _id: new ObjectId(topicId) },\n      { $set: updateData }\n    );\n\n    if (result.matchedCount === 0) {\n      return { success: false, error: \"Topic not found\" };\n    }\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error updating topic:\", error);\n    return { success: false, error: \"Failed to update topic\" };\n  }\n}\n\n// DELETE - Delete a topic\nexport async function deleteTopic(topicId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    // Remove topic from linkedTopics arrays of other topics\n    await collection.updateMany(\n      { linkedTopics: new ObjectId(topicId) },\n      { $pull: { linkedTopics: new ObjectId(topicId) } }\n    );\n\n    // Remove parentTopicId references\n    await collection.updateMany(\n      { parentTopicId: new ObjectId(topicId) },\n      { $unset: { parentTopicId: \"\" } }\n    );\n\n    const result = await collection.deleteOne({ _id: new ObjectId(topicId) });\n\n    if (result.deletedCount === 0) {\n      return { success: false, error: \"Topic not found\" };\n    }\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting topic:\", error);\n    return { success: false, error: \"Failed to delete topic\" };\n  }\n}\n\n// LINK - Link a topic to another topic\nexport async function linkTopics(topicId: string, linkedTopicId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    if (topicId === linkedTopicId) {\n      return { success: false, error: \"A topic cannot be linked to itself\" };\n    }\n\n    // Add bidirectional link\n    await collection.updateOne(\n      { _id: new ObjectId(topicId) },\n      { $addToSet: { linkedTopics: new ObjectId(linkedTopicId) } }\n    );\n\n    await collection.updateOne(\n      { _id: new ObjectId(linkedTopicId) },\n      { $addToSet: { linkedTopics: new ObjectId(topicId) } }\n    );\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error linking topics:\", error);\n    return { success: false, error: \"Failed to link topics\" };\n  }\n}\n\n// UNLINK - Unlink a topic from another topic\nexport async function unlinkTopics(topicId: string, linkedTopicId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    // Remove bidirectional link\n    await collection.updateOne(\n      { _id: new ObjectId(topicId) },\n      { $pull: { linkedTopics: new ObjectId(linkedTopicId) } }\n    );\n\n    await collection.updateOne(\n      { _id: new ObjectId(linkedTopicId) },\n      { $pull: { linkedTopics: new ObjectId(topicId) } }\n    );\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error unlinking topics:\", error);\n    return { success: false, error: \"Failed to unlink topics\" };\n  }\n}\n"],"names":[],"mappings":";;;;;;;IAwRsB,cAAA,WAAA,GAAA,IAAA,iQAAA,EAAA,8CAAA,sPAAA,EAAA,KAAA,GAAA,4PAAA,EAAA","debugId":null}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsingh/Desktop/GitHub/denotesCRUD/app/actions.ts"],"sourcesContent":["\"use server\";\n\nimport client from \"@/lib/mongodb\";\nimport { ObjectId } from \"mongodb\";\nimport { revalidatePath } from \"next/cache\";\n\nexport interface Task {\n  _id?: string;\n  title: string;\n  description: string;\n  completed: boolean;\n  createdAt?: Date;\n  updatedAt?: Date;\n}\n\nexport interface Topic {\n  _id?: string;\n  title: string;\n  description: string;\n  linkedTopics: string[]; // Array of topic IDs this topic is linked to\n  parentTopicId?: string; // Optional parent for hierarchical display\n  createdAt?: Date;\n  updatedAt?: Date;\n}\n\nexport async function testDatabaseConnection() {\n  let isConnected = false;\n  try {\n    const mongoClient = await client.connect();\n    // Send a ping to confirm a successful connection\n    await mongoClient.db(\"admin\").command({ ping: 1 });\n    console.log(\n      \"Pinged your deployment. You successfully connected to MongoDB!\",\n    ); // because this is a server action, the console.log will be outputted to your terminal not in the browser\n    return !isConnected;\n  } catch (e) {\n    console.error(e);\n    return isConnected;\n  }\n}\n\n// CREATE - Add a new task\nexport async function createTask(formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const newTask = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      completed: false,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    const result = await collection.insertOne(newTask);\n    revalidatePath(\"/crud\");\n    return { success: true, id: result.insertedId.toString() };\n  } catch (error) {\n    console.error(\"Error creating task:\", error);\n    return { success: false, error: \"Failed to create task\" };\n  }\n}\n\n// READ - Get all tasks\nexport async function getTasks(): Promise<Task[]> {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const tasks = await collection\n      .find({})\n      .sort({ createdAt: -1 })\n      .toArray();\n\n    return tasks.map((task) => ({\n      _id: task._id.toString(),\n      title: task.title,\n      description: task.description,\n      completed: task.completed,\n      createdAt: task.createdAt,\n      updatedAt: task.updatedAt,\n    }));\n  } catch (error) {\n    console.error(\"Error fetching tasks:\", error);\n    return [];\n  }\n}\n\n// UPDATE - Update a task\nexport async function updateTask(taskId: string, formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n    const completed = formData.get(\"completed\") === \"true\";\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const updateData: any = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      completed,\n      updatedAt: new Date(),\n    };\n\n    const result = await collection.updateOne(\n      { _id: new ObjectId(taskId) },\n      { $set: updateData }\n    );\n\n    if (result.matchedCount === 0) {\n      return { success: false, error: \"Task not found\" };\n    }\n\n    revalidatePath(\"/crud\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error updating task:\", error);\n    return { success: false, error: \"Failed to update task\" };\n  }\n}\n\n// DELETE - Delete a task\nexport async function deleteTask(taskId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const result = await collection.deleteOne({ _id: new ObjectId(taskId) });\n\n    if (result.deletedCount === 0) {\n      return { success: false, error: \"Task not found\" };\n    }\n\n    revalidatePath(\"/crud\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting task:\", error);\n    return { success: false, error: \"Failed to delete task\" };\n  }\n}\n\n// TOGGLE - Toggle task completion status\nexport async function toggleTask(taskId: string, completed: boolean) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const result = await collection.updateOne(\n      { _id: new ObjectId(taskId) },\n      { $set: { completed: !completed, updatedAt: new Date() } }\n    );\n\n    if (result.matchedCount === 0) {\n      return { success: false, error: \"Task not found\" };\n    }\n\n    revalidatePath(\"/crud\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error toggling task:\", error);\n    return { success: false, error: \"Failed to toggle task\" };\n  }\n}\n\n// ========== TOPIC CRUD OPERATIONS ==========\n\n// CREATE - Add a new topic\nexport async function createTopic(formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n    const parentTopicId = formData.get(\"parentTopicId\") as string;\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const newTopic: any = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      linkedTopics: [],\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    if (parentTopicId && parentTopicId.trim() !== \"\") {\n      newTopic.parentTopicId = parentTopicId.trim();\n    }\n\n    const result = await collection.insertOne(newTopic);\n    revalidatePath(\"/topics\");\n    return { success: true, id: result.insertedId.toString() };\n  } catch (error) {\n    console.error(\"Error creating topic:\", error);\n    return { success: false, error: \"Failed to create topic\" };\n  }\n}\n\n// READ - Get all topics with full details\nexport async function getTopics(): Promise<Topic[]> {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const topics = await collection\n      .find({})\n      .sort({ createdAt: -1 })\n      .toArray();\n\n    return topics.map((topic) => ({\n      _id: topic._id.toString(),\n      title: topic.title,\n      description: topic.description || \"\",\n      linkedTopics: (topic.linkedTopics || []).map((id: ObjectId) =>\n        id.toString()\n      ),\n      parentTopicId: topic.parentTopicId?.toString(),\n      createdAt: topic.createdAt,\n      updatedAt: topic.updatedAt,\n    }));\n  } catch (error) {\n    console.error(\"Error fetching topics:\", error);\n    return [];\n  }\n}\n\n// READ - Get a single topic by ID\nexport async function getTopic(topicId: string): Promise<Topic | null> {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const topic = await collection.findOne({ _id: new ObjectId(topicId) });\n\n    if (!topic) {\n      return null;\n    }\n\n    return {\n      _id: topic._id.toString(),\n      title: topic.title,\n      description: topic.description || \"\",\n      linkedTopics: (topic.linkedTopics || []).map((id: ObjectId) =>\n        id.toString()\n      ),\n      parentTopicId: topic.parentTopicId?.toString(),\n      createdAt: topic.createdAt,\n      updatedAt: topic.updatedAt,\n    };\n  } catch (error) {\n    console.error(\"Error fetching topic:\", error);\n    return null;\n  }\n}\n\n// UPDATE - Update a topic\nexport async function updateTopic(topicId: string, formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n    const parentTopicId = formData.get(\"parentTopicId\") as string;\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const updateData: any = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      updatedAt: new Date(),\n    };\n\n    if (parentTopicId && parentTopicId.trim() !== \"\" && parentTopicId !== topicId) {\n      updateData.parentTopicId = parentTopicId.trim();\n    } else if (parentTopicId === \"\") {\n      updateData.parentTopicId = null;\n    }\n\n    const result = await collection.updateOne(\n      { _id: new ObjectId(topicId) },\n      { $set: updateData }\n    );\n\n    if (result.matchedCount === 0) {\n      return { success: false, error: \"Topic not found\" };\n    }\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error updating topic:\", error);\n    return { success: false, error: \"Failed to update topic\" };\n  }\n}\n\n// DELETE - Delete a topic\nexport async function deleteTopic(topicId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    // Remove topic from linkedTopics arrays of other topics\n    await collection.updateMany(\n      { linkedTopics: new ObjectId(topicId) },\n      { $pull: { linkedTopics: new ObjectId(topicId) } }\n    );\n\n    // Remove parentTopicId references\n    await collection.updateMany(\n      { parentTopicId: new ObjectId(topicId) },\n      { $unset: { parentTopicId: \"\" } }\n    );\n\n    const result = await collection.deleteOne({ _id: new ObjectId(topicId) });\n\n    if (result.deletedCount === 0) {\n      return { success: false, error: \"Topic not found\" };\n    }\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting topic:\", error);\n    return { success: false, error: \"Failed to delete topic\" };\n  }\n}\n\n// LINK - Link a topic to another topic\nexport async function linkTopics(topicId: string, linkedTopicId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    if (topicId === linkedTopicId) {\n      return { success: false, error: \"A topic cannot be linked to itself\" };\n    }\n\n    // Add bidirectional link\n    await collection.updateOne(\n      { _id: new ObjectId(topicId) },\n      { $addToSet: { linkedTopics: new ObjectId(linkedTopicId) } }\n    );\n\n    await collection.updateOne(\n      { _id: new ObjectId(linkedTopicId) },\n      { $addToSet: { linkedTopics: new ObjectId(topicId) } }\n    );\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error linking topics:\", error);\n    return { success: false, error: \"Failed to link topics\" };\n  }\n}\n\n// UNLINK - Unlink a topic from another topic\nexport async function unlinkTopics(topicId: string, linkedTopicId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    // Remove bidirectional link\n    await collection.updateOne(\n      { _id: new ObjectId(topicId) },\n      { $pull: { linkedTopics: new ObjectId(linkedTopicId) } }\n    );\n\n    await collection.updateOne(\n      { _id: new ObjectId(linkedTopicId) },\n      { $pull: { linkedTopics: new ObjectId(topicId) } }\n    );\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error unlinking topics:\", error);\n    return { success: false, error: \"Failed to unlink topics\" };\n  }\n}\n"],"names":[],"mappings":";;;;;;;IAoUsB,cAAA,WAAA,GAAA,IAAA,iQAAA,EAAA,8CAAA,sPAAA,EAAA,KAAA,GAAA,4PAAA,EAAA","debugId":null}},
    {"offset": {"line": 79, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsingh/Desktop/GitHub/denotesCRUD/app/actions.ts"],"sourcesContent":["\"use server\";\n\nimport client from \"@/lib/mongodb\";\nimport { ObjectId } from \"mongodb\";\nimport { revalidatePath } from \"next/cache\";\n\nexport interface Task {\n  _id?: string;\n  title: string;\n  description: string;\n  completed: boolean;\n  createdAt?: Date;\n  updatedAt?: Date;\n}\n\nexport interface Topic {\n  _id?: string;\n  title: string;\n  description: string;\n  linkedTopics: string[]; // Array of topic IDs this topic is linked to\n  parentTopicId?: string; // Optional parent for hierarchical display\n  createdAt?: Date;\n  updatedAt?: Date;\n}\n\nexport async function testDatabaseConnection() {\n  let isConnected = false;\n  try {\n    const mongoClient = await client.connect();\n    // Send a ping to confirm a successful connection\n    await mongoClient.db(\"admin\").command({ ping: 1 });\n    console.log(\n      \"Pinged your deployment. You successfully connected to MongoDB!\",\n    ); // because this is a server action, the console.log will be outputted to your terminal not in the browser\n    return !isConnected;\n  } catch (e) {\n    console.error(e);\n    return isConnected;\n  }\n}\n\n// CREATE - Add a new task\nexport async function createTask(formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const newTask = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      completed: false,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    const result = await collection.insertOne(newTask);\n    revalidatePath(\"/crud\");\n    return { success: true, id: result.insertedId.toString() };\n  } catch (error) {\n    console.error(\"Error creating task:\", error);\n    return { success: false, error: \"Failed to create task\" };\n  }\n}\n\n// READ - Get all tasks\nexport async function getTasks(): Promise<Task[]> {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const tasks = await collection\n      .find({})\n      .sort({ createdAt: -1 })\n      .toArray();\n\n    return tasks.map((task) => ({\n      _id: task._id.toString(),\n      title: task.title,\n      description: task.description,\n      completed: task.completed,\n      createdAt: task.createdAt,\n      updatedAt: task.updatedAt,\n    }));\n  } catch (error) {\n    console.error(\"Error fetching tasks:\", error);\n    return [];\n  }\n}\n\n// UPDATE - Update a task\nexport async function updateTask(taskId: string, formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n    const completed = formData.get(\"completed\") === \"true\";\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const updateData: any = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      completed,\n      updatedAt: new Date(),\n    };\n\n    const result = await collection.updateOne(\n      { _id: new ObjectId(taskId) },\n      { $set: updateData }\n    );\n\n    if (result.matchedCount === 0) {\n      return { success: false, error: \"Task not found\" };\n    }\n\n    revalidatePath(\"/crud\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error updating task:\", error);\n    return { success: false, error: \"Failed to update task\" };\n  }\n}\n\n// DELETE - Delete a task\nexport async function deleteTask(taskId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const result = await collection.deleteOne({ _id: new ObjectId(taskId) });\n\n    if (result.deletedCount === 0) {\n      return { success: false, error: \"Task not found\" };\n    }\n\n    revalidatePath(\"/crud\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting task:\", error);\n    return { success: false, error: \"Failed to delete task\" };\n  }\n}\n\n// TOGGLE - Toggle task completion status\nexport async function toggleTask(taskId: string, completed: boolean) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const result = await collection.updateOne(\n      { _id: new ObjectId(taskId) },\n      { $set: { completed: !completed, updatedAt: new Date() } }\n    );\n\n    if (result.matchedCount === 0) {\n      return { success: false, error: \"Task not found\" };\n    }\n\n    revalidatePath(\"/crud\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error toggling task:\", error);\n    return { success: false, error: \"Failed to toggle task\" };\n  }\n}\n\n// ========== TOPIC CRUD OPERATIONS ==========\n\n// CREATE - Add a new topic\nexport async function createTopic(formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n    const parentTopicId = formData.get(\"parentTopicId\") as string;\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const newTopic: any = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      linkedTopics: [],\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    if (parentTopicId && parentTopicId.trim() !== \"\") {\n      newTopic.parentTopicId = parentTopicId.trim();\n    }\n\n    const result = await collection.insertOne(newTopic);\n    revalidatePath(\"/topics\");\n    return { success: true, id: result.insertedId.toString() };\n  } catch (error) {\n    console.error(\"Error creating topic:\", error);\n    return { success: false, error: \"Failed to create topic\" };\n  }\n}\n\n// READ - Get all topics with full details\nexport async function getTopics(): Promise<Topic[]> {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const topics = await collection\n      .find({})\n      .sort({ createdAt: -1 })\n      .toArray();\n\n    return topics.map((topic) => ({\n      _id: topic._id.toString(),\n      title: topic.title,\n      description: topic.description || \"\",\n      linkedTopics: (topic.linkedTopics || []).map((id: ObjectId) =>\n        id.toString()\n      ),\n      parentTopicId: topic.parentTopicId?.toString(),\n      createdAt: topic.createdAt,\n      updatedAt: topic.updatedAt,\n    }));\n  } catch (error) {\n    console.error(\"Error fetching topics:\", error);\n    return [];\n  }\n}\n\n// READ - Get a single topic by ID\nexport async function getTopic(topicId: string): Promise<Topic | null> {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const topic = await collection.findOne({ _id: new ObjectId(topicId) });\n\n    if (!topic) {\n      return null;\n    }\n\n    return {\n      _id: topic._id.toString(),\n      title: topic.title,\n      description: topic.description || \"\",\n      linkedTopics: (topic.linkedTopics || []).map((id: ObjectId) =>\n        id.toString()\n      ),\n      parentTopicId: topic.parentTopicId?.toString(),\n      createdAt: topic.createdAt,\n      updatedAt: topic.updatedAt,\n    };\n  } catch (error) {\n    console.error(\"Error fetching topic:\", error);\n    return null;\n  }\n}\n\n// UPDATE - Update a topic\nexport async function updateTopic(topicId: string, formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n    const parentTopicId = formData.get(\"parentTopicId\") as string;\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const updateData: any = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      updatedAt: new Date(),\n    };\n\n    if (parentTopicId && parentTopicId.trim() !== \"\" && parentTopicId !== topicId) {\n      updateData.parentTopicId = parentTopicId.trim();\n    } else if (parentTopicId === \"\") {\n      updateData.parentTopicId = null;\n    }\n\n    const result = await collection.updateOne(\n      { _id: new ObjectId(topicId) },\n      { $set: updateData }\n    );\n\n    if (result.matchedCount === 0) {\n      return { success: false, error: \"Topic not found\" };\n    }\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error updating topic:\", error);\n    return { success: false, error: \"Failed to update topic\" };\n  }\n}\n\n// DELETE - Delete a topic\nexport async function deleteTopic(topicId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    // Remove topic from linkedTopics arrays of other topics\n    await collection.updateMany(\n      { linkedTopics: new ObjectId(topicId) },\n      { $pull: { linkedTopics: new ObjectId(topicId) } }\n    );\n\n    // Remove parentTopicId references\n    await collection.updateMany(\n      { parentTopicId: new ObjectId(topicId) },\n      { $unset: { parentTopicId: \"\" } }\n    );\n\n    const result = await collection.deleteOne({ _id: new ObjectId(topicId) });\n\n    if (result.deletedCount === 0) {\n      return { success: false, error: \"Topic not found\" };\n    }\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting topic:\", error);\n    return { success: false, error: \"Failed to delete topic\" };\n  }\n}\n\n// LINK - Link a topic to another topic\nexport async function linkTopics(topicId: string, linkedTopicId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    if (topicId === linkedTopicId) {\n      return { success: false, error: \"A topic cannot be linked to itself\" };\n    }\n\n    // Add bidirectional link\n    await collection.updateOne(\n      { _id: new ObjectId(topicId) },\n      { $addToSet: { linkedTopics: new ObjectId(linkedTopicId) } }\n    );\n\n    await collection.updateOne(\n      { _id: new ObjectId(linkedTopicId) },\n      { $addToSet: { linkedTopics: new ObjectId(topicId) } }\n    );\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error linking topics:\", error);\n    return { success: false, error: \"Failed to link topics\" };\n  }\n}\n\n// UNLINK - Unlink a topic from another topic\nexport async function unlinkTopics(topicId: string, linkedTopicId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    // Remove bidirectional link\n    await collection.updateOne(\n      { _id: new ObjectId(topicId) },\n      { $pull: { linkedTopics: new ObjectId(linkedTopicId) } }\n    );\n\n    await collection.updateOne(\n      { _id: new ObjectId(linkedTopicId) },\n      { $pull: { linkedTopics: new ObjectId(topicId) } }\n    );\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error unlinking topics:\", error);\n    return { success: false, error: \"Failed to unlink topics\" };\n  }\n}\n"],"names":[],"mappings":";;;;;;;IAqWsB,aAAA,WAAA,GAAA,IAAA,iQAAA,EAAA,8CAAA,sPAAA,EAAA,KAAA,GAAA,4PAAA,EAAA","debugId":null}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsingh/Desktop/GitHub/denotesCRUD/app/actions.ts"],"sourcesContent":["\"use server\";\n\nimport client from \"@/lib/mongodb\";\nimport { ObjectId } from \"mongodb\";\nimport { revalidatePath } from \"next/cache\";\n\nexport interface Task {\n  _id?: string;\n  title: string;\n  description: string;\n  completed: boolean;\n  createdAt?: Date;\n  updatedAt?: Date;\n}\n\nexport interface Topic {\n  _id?: string;\n  title: string;\n  description: string;\n  linkedTopics: string[]; // Array of topic IDs this topic is linked to\n  parentTopicId?: string; // Optional parent for hierarchical display\n  createdAt?: Date;\n  updatedAt?: Date;\n}\n\nexport async function testDatabaseConnection() {\n  let isConnected = false;\n  try {\n    const mongoClient = await client.connect();\n    // Send a ping to confirm a successful connection\n    await mongoClient.db(\"admin\").command({ ping: 1 });\n    console.log(\n      \"Pinged your deployment. You successfully connected to MongoDB!\",\n    ); // because this is a server action, the console.log will be outputted to your terminal not in the browser\n    return !isConnected;\n  } catch (e) {\n    console.error(e);\n    return isConnected;\n  }\n}\n\n// CREATE - Add a new task\nexport async function createTask(formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const newTask = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      completed: false,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    const result = await collection.insertOne(newTask);\n    revalidatePath(\"/crud\");\n    return { success: true, id: result.insertedId.toString() };\n  } catch (error) {\n    console.error(\"Error creating task:\", error);\n    return { success: false, error: \"Failed to create task\" };\n  }\n}\n\n// READ - Get all tasks\nexport async function getTasks(): Promise<Task[]> {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const tasks = await collection\n      .find({})\n      .sort({ createdAt: -1 })\n      .toArray();\n\n    return tasks.map((task) => ({\n      _id: task._id.toString(),\n      title: task.title,\n      description: task.description,\n      completed: task.completed,\n      createdAt: task.createdAt,\n      updatedAt: task.updatedAt,\n    }));\n  } catch (error) {\n    console.error(\"Error fetching tasks:\", error);\n    return [];\n  }\n}\n\n// UPDATE - Update a task\nexport async function updateTask(taskId: string, formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n    const completed = formData.get(\"completed\") === \"true\";\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const updateData: any = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      completed,\n      updatedAt: new Date(),\n    };\n\n    const result = await collection.updateOne(\n      { _id: new ObjectId(taskId) },\n      { $set: updateData }\n    );\n\n    if (result.matchedCount === 0) {\n      return { success: false, error: \"Task not found\" };\n    }\n\n    revalidatePath(\"/crud\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error updating task:\", error);\n    return { success: false, error: \"Failed to update task\" };\n  }\n}\n\n// DELETE - Delete a task\nexport async function deleteTask(taskId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const result = await collection.deleteOne({ _id: new ObjectId(taskId) });\n\n    if (result.deletedCount === 0) {\n      return { success: false, error: \"Task not found\" };\n    }\n\n    revalidatePath(\"/crud\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting task:\", error);\n    return { success: false, error: \"Failed to delete task\" };\n  }\n}\n\n// TOGGLE - Toggle task completion status\nexport async function toggleTask(taskId: string, completed: boolean) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"tasks\");\n\n    const result = await collection.updateOne(\n      { _id: new ObjectId(taskId) },\n      { $set: { completed: !completed, updatedAt: new Date() } }\n    );\n\n    if (result.matchedCount === 0) {\n      return { success: false, error: \"Task not found\" };\n    }\n\n    revalidatePath(\"/crud\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error toggling task:\", error);\n    return { success: false, error: \"Failed to toggle task\" };\n  }\n}\n\n// ========== TOPIC CRUD OPERATIONS ==========\n\n// CREATE - Add a new topic\nexport async function createTopic(formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n    const parentTopicId = formData.get(\"parentTopicId\") as string;\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const newTopic: any = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      linkedTopics: [],\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    if (parentTopicId && parentTopicId.trim() !== \"\") {\n      newTopic.parentTopicId = parentTopicId.trim();\n    }\n\n    const result = await collection.insertOne(newTopic);\n    revalidatePath(\"/topics\");\n    return { success: true, id: result.insertedId.toString() };\n  } catch (error) {\n    console.error(\"Error creating topic:\", error);\n    return { success: false, error: \"Failed to create topic\" };\n  }\n}\n\n// READ - Get all topics with full details\nexport async function getTopics(): Promise<Topic[]> {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const topics = await collection\n      .find({})\n      .sort({ createdAt: -1 })\n      .toArray();\n\n    return topics.map((topic) => ({\n      _id: topic._id.toString(),\n      title: topic.title,\n      description: topic.description || \"\",\n      linkedTopics: (topic.linkedTopics || []).map((id: ObjectId) =>\n        id.toString()\n      ),\n      parentTopicId: topic.parentTopicId?.toString(),\n      createdAt: topic.createdAt,\n      updatedAt: topic.updatedAt,\n    }));\n  } catch (error) {\n    console.error(\"Error fetching topics:\", error);\n    return [];\n  }\n}\n\n// READ - Get a single topic by ID\nexport async function getTopic(topicId: string): Promise<Topic | null> {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const topic = await collection.findOne({ _id: new ObjectId(topicId) });\n\n    if (!topic) {\n      return null;\n    }\n\n    return {\n      _id: topic._id.toString(),\n      title: topic.title,\n      description: topic.description || \"\",\n      linkedTopics: (topic.linkedTopics || []).map((id: ObjectId) =>\n        id.toString()\n      ),\n      parentTopicId: topic.parentTopicId?.toString(),\n      createdAt: topic.createdAt,\n      updatedAt: topic.updatedAt,\n    };\n  } catch (error) {\n    console.error(\"Error fetching topic:\", error);\n    return null;\n  }\n}\n\n// UPDATE - Update a topic\nexport async function updateTopic(topicId: string, formData: FormData) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    const title = formData.get(\"title\") as string;\n    const description = formData.get(\"description\") as string;\n    const parentTopicId = formData.get(\"parentTopicId\") as string;\n\n    if (!title || title.trim() === \"\") {\n      return { success: false, error: \"Title is required\" };\n    }\n\n    const updateData: any = {\n      title: title.trim(),\n      description: description?.trim() || \"\",\n      updatedAt: new Date(),\n    };\n\n    if (parentTopicId && parentTopicId.trim() !== \"\" && parentTopicId !== topicId) {\n      updateData.parentTopicId = parentTopicId.trim();\n    } else if (parentTopicId === \"\") {\n      updateData.parentTopicId = null;\n    }\n\n    const result = await collection.updateOne(\n      { _id: new ObjectId(topicId) },\n      { $set: updateData }\n    );\n\n    if (result.matchedCount === 0) {\n      return { success: false, error: \"Topic not found\" };\n    }\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error updating topic:\", error);\n    return { success: false, error: \"Failed to update topic\" };\n  }\n}\n\n// DELETE - Delete a topic\nexport async function deleteTopic(topicId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    // Remove topic from linkedTopics arrays of other topics\n    await collection.updateMany(\n      { linkedTopics: new ObjectId(topicId) },\n      { $pull: { linkedTopics: new ObjectId(topicId) } }\n    );\n\n    // Remove parentTopicId references\n    await collection.updateMany(\n      { parentTopicId: new ObjectId(topicId) },\n      { $unset: { parentTopicId: \"\" } }\n    );\n\n    const result = await collection.deleteOne({ _id: new ObjectId(topicId) });\n\n    if (result.deletedCount === 0) {\n      return { success: false, error: \"Topic not found\" };\n    }\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting topic:\", error);\n    return { success: false, error: \"Failed to delete topic\" };\n  }\n}\n\n// LINK - Link a topic to another topic\nexport async function linkTopics(topicId: string, linkedTopicId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    if (topicId === linkedTopicId) {\n      return { success: false, error: \"A topic cannot be linked to itself\" };\n    }\n\n    // Add bidirectional link\n    await collection.updateOne(\n      { _id: new ObjectId(topicId) },\n      { $addToSet: { linkedTopics: new ObjectId(linkedTopicId) } }\n    );\n\n    await collection.updateOne(\n      { _id: new ObjectId(linkedTopicId) },\n      { $addToSet: { linkedTopics: new ObjectId(topicId) } }\n    );\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error linking topics:\", error);\n    return { success: false, error: \"Failed to link topics\" };\n  }\n}\n\n// UNLINK - Unlink a topic from another topic\nexport async function unlinkTopics(topicId: string, linkedTopicId: string) {\n  try {\n    const mongoClient = await client.connect();\n    const db = mongoClient.db();\n    const collection = db.collection(\"topics\");\n\n    // Remove bidirectional link\n    await collection.updateOne(\n      { _id: new ObjectId(topicId) },\n      { $pull: { linkedTopics: new ObjectId(linkedTopicId) } }\n    );\n\n    await collection.updateOne(\n      { _id: new ObjectId(linkedTopicId) },\n      { $pull: { linkedTopics: new ObjectId(topicId) } }\n    );\n\n    revalidatePath(\"/topics\");\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error unlinking topics:\", error);\n    return { success: false, error: \"Failed to unlink topics\" };\n  }\n}\n"],"names":[],"mappings":";;;;;;;IAmYsB,eAAA,WAAA,GAAA,IAAA,iQAAA,EAAA,8CAAA,sPAAA,EAAA,KAAA,GAAA,4PAAA,EAAA","debugId":null}},
    {"offset": {"line": 109, "column": 0}, "map": {"version":3,"sources":["file:///Users/vaibhavsingh/Desktop/GitHub/denotesCRUD/app/topics/page.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport {\n  createTopic,\n  getTopics,\n  getTopic,\n  updateTopic,\n  deleteTopic,\n  linkTopics,\n  unlinkTopics,\n  type Topic,\n} from \"../actions\";\n\ninterface TopicNode extends Topic {\n  children?: TopicNode[];\n}\n\nexport default function TopicsPage() {\n  const [topics, setTopics] = useState<Topic[]>([]);\n  const [selectedTopic, setSelectedTopic] = useState<Topic | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [editingTopic, setEditingTopic] = useState<Topic | null>(null);\n  const [formData, setFormData] = useState({\n    title: \"\",\n    description: \"\",\n    parentTopicId: \"\",\n  });\n  const [error, setError] = useState<string | null>(null);\n  const [success, setSuccess] = useState<string | null>(null);\n  const [expandedNodes, setExpandedNodes] = useState<Set<string>>(new Set());\n\n  useEffect(() => {\n    loadTopics();\n  }, []);\n\n  const loadTopics = async () => {\n    setLoading(true);\n    try {\n      const fetchedTopics = await getTopics();\n      setTopics(fetchedTopics);\n      if (selectedTopic) {\n        // Refresh selected topic data\n        const refreshed = await getTopic(selectedTopic._id!);\n        if (refreshed) {\n          setSelectedTopic(refreshed);\n        }\n      }\n    } catch (err) {\n      setError(\"Failed to load topics\");\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Build hierarchical tree structure\n  const buildTree = (topics: Topic[]): TopicNode[] => {\n    const topicMap = new Map<string, TopicNode>();\n    const rootTopics: TopicNode[] = [];\n\n    // Create map of all topics\n    topics.forEach((topic) => {\n      topicMap.set(topic._id!, { ...topic, children: [] });\n    });\n\n    // Build tree structure\n    topics.forEach((topic) => {\n      const node = topicMap.get(topic._id!)!;\n      if (topic.parentTopicId && topicMap.has(topic.parentTopicId)) {\n        const parent = topicMap.get(topic.parentTopicId)!;\n        if (!parent.children) {\n          parent.children = [];\n        }\n        parent.children.push(node);\n      } else {\n        rootTopics.push(node);\n      }\n    });\n\n    // Sort by title\n    const sortTopics = (nodes: TopicNode[]) => {\n      nodes.sort((a, b) => a.title.localeCompare(b.title));\n      nodes.forEach((node) => {\n        if (node.children) {\n          sortTopics(node.children);\n        }\n      });\n    };\n\n    sortTopics(rootTopics);\n    return rootTopics;\n  };\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setError(null);\n    setSuccess(null);\n\n    if (editingTopic) {\n      // Update existing topic\n      const formDataObj = new FormData();\n      formDataObj.append(\"title\", formData.title);\n      formDataObj.append(\"description\", formData.description);\n      formDataObj.append(\"parentTopicId\", formData.parentTopicId);\n\n      const result = await updateTopic(editingTopic._id!, formDataObj);\n      if (result.success) {\n        setSuccess(\"Topic updated successfully!\");\n        setEditingTopic(null);\n        setFormData({ title: \"\", description: \"\", parentTopicId: \"\" });\n        await loadTopics();\n      } else {\n        setError(result.error || \"Failed to update topic\");\n      }\n    } else {\n      // Create new topic\n      const formDataObj = new FormData();\n      formDataObj.append(\"title\", formData.title);\n      formDataObj.append(\"description\", formData.description);\n      formDataObj.append(\"parentTopicId\", formData.parentTopicId);\n\n      const result = await createTopic(formDataObj);\n      if (result.success) {\n        setSuccess(\"Topic created successfully!\");\n        setFormData({ title: \"\", description: \"\", parentTopicId: \"\" });\n        await loadTopics();\n      } else {\n        setError(result.error || \"Failed to create topic\");\n      }\n    }\n  };\n\n  const handleEdit = (topic: Topic) => {\n    setEditingTopic(topic);\n    setFormData({\n      title: topic.title,\n      description: topic.description,\n      parentTopicId: topic.parentTopicId || \"\",\n    });\n    setSelectedTopic(topic);\n    setError(null);\n    setSuccess(null);\n  };\n\n  const handleCancel = () => {\n    setEditingTopic(null);\n    setFormData({ title: \"\", description: \"\", parentTopicId: \"\" });\n    setError(null);\n    setSuccess(null);\n  };\n\n  const handleDelete = async (topicId: string) => {\n    if (!confirm(\"Are you sure you want to delete this topic?\")) {\n      return;\n    }\n\n    setError(null);\n    setSuccess(null);\n    const result = await deleteTopic(topicId);\n    if (result.success) {\n      setSuccess(\"Topic deleted successfully!\");\n      if (selectedTopic?._id === topicId) {\n        setSelectedTopic(null);\n      }\n      await loadTopics();\n    } else {\n      setError(result.error || \"Failed to delete topic\");\n    }\n  };\n\n  const handleTopicClick = async (topicId: string) => {\n    const topic = await getTopic(topicId);\n    if (topic) {\n      setSelectedTopic(topic);\n      setEditingTopic(null);\n      setFormData({ title: \"\", description: \"\", parentTopicId: \"\" });\n    }\n  };\n\n  const handleLinkTopic = async (linkedTopicId: string) => {\n    if (!selectedTopic) return;\n\n    setError(null);\n    const result = await linkTopics(selectedTopic._id!, linkedTopicId);\n    if (result.success) {\n      setSuccess(\"Topics linked successfully!\");\n      await loadTopics();\n    } else {\n      setError(result.error || \"Failed to link topics\");\n    }\n  };\n\n  const handleUnlinkTopic = async (linkedTopicId: string) => {\n    if (!selectedTopic) return;\n\n    setError(null);\n    const result = await unlinkTopics(selectedTopic._id!, linkedTopicId);\n    if (result.success) {\n      setSuccess(\"Topics unlinked successfully!\");\n      await loadTopics();\n    } else {\n      setError(result.error || \"Failed to unlink topics\");\n    }\n  };\n\n  const toggleExpand = (topicId: string) => {\n    const newExpanded = new Set(expandedNodes);\n    if (newExpanded.has(topicId)) {\n      newExpanded.delete(topicId);\n    } else {\n      newExpanded.add(topicId);\n    }\n    setExpandedNodes(newExpanded);\n  };\n\n  const renderTreeNode = (node: TopicNode, level: number = 0): JSX.Element => {\n    const hasChildren = node.children && node.children.length > 0;\n    const isExpanded = expandedNodes.has(node._id!);\n    const isSelected = selectedTopic?._id === node._id;\n\n    return (\n      <div key={node._id} className=\"select-none\">\n        <div\n          className={`flex items-center gap-2 py-1 px-2 rounded cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 ${\n            isSelected ? \"bg-blue-100 dark:bg-blue-900\" : \"\"\n          }`}\n          style={{ paddingLeft: `${level * 20 + 8}px` }}\n        >\n          {hasChildren && (\n            <button\n              onClick={(e) => {\n                e.stopPropagation();\n                toggleExpand(node._id!);\n              }}\n              className=\"w-4 h-4 flex items-center justify-center text-xs\"\n            >\n              {isExpanded ? \"\" : \"\"}\n            </button>\n          )}\n          {!hasChildren && <span className=\"w-4\"></span>}\n          <span\n            onClick={() => handleTopicClick(node._id!)}\n            className=\"flex-1 text-sm font-medium text-gray-900 dark:text-white\"\n          >\n            {node.title}\n          </span>\n        </div>\n        {hasChildren && isExpanded && (\n          <div>\n            {node.children!.map((child) => renderTreeNode(child, level + 1))}\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  const topicTree = buildTree(topics);\n  const availableTopics = topics.filter(\n    (t) => t._id !== editingTopic?._id && t._id !== selectedTopic?._id\n  );\n\n  return (\n    <div className=\"min-h-screen bg-gradient-to-br from-purple-50 to-indigo-100 dark:from-gray-900 dark:to-gray-800\">\n      <div className=\"flex h-screen\">\n        {/* Left Sidebar - Hierarchical Topics */}\n        <div className=\"w-80 bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 flex flex-col\">\n          <div className=\"p-4 border-b border-gray-200 dark:border-gray-700\">\n            <h2 className=\"text-xl font-bold text-gray-900 dark:text-white mb-2\">\n              Topics\n            </h2>\n            <button\n              onClick={() => {\n                setEditingTopic(null);\n                setSelectedTopic(null);\n                setFormData({ title: \"\", description: \"\", parentTopicId: \"\" });\n                setError(null);\n                setSuccess(null);\n              }}\n              className=\"w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg transition-colors text-sm\"\n            >\n              + New Topic\n            </button>\n          </div>\n          <div className=\"flex-1 overflow-y-auto p-2\">\n            {loading ? (\n              <div className=\"text-center py-8 text-gray-600 dark:text-gray-400\">\n                Loading topics...\n              </div>\n            ) : topicTree.length === 0 ? (\n              <div className=\"text-center py-8 text-gray-600 dark:text-gray-400\">\n                No topics yet. Create your first topic!\n              </div>\n            ) : (\n              <div>{topicTree.map((node) => renderTreeNode(node))}</div>\n            )}\n          </div>\n        </div>\n\n        {/* Right Panel - Topic Details and Form */}\n        <div className=\"flex-1 overflow-y-auto p-8\">\n          <div className=\"max-w-4xl mx-auto\">\n            <h1 className=\"text-3xl font-bold text-gray-900 dark:text-white mb-6\">\n              Topic Manager\n            </h1>\n\n            {/* Success/Error Messages */}\n            {success && (\n              <div className=\"mb-6 p-4 bg-green-100 border border-green-400 text-green-700 rounded-lg\">\n                {success}\n              </div>\n            )}\n            {error && (\n              <div className=\"mb-6 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg\">\n                {error}\n              </div>\n            )}\n\n            {/* Topic Form */}\n            <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 mb-8\">\n              <h2 className=\"text-2xl font-semibold text-gray-900 dark:text-white mb-4\">\n                {editingTopic ? \"Edit Topic\" : \"Create New Topic\"}\n              </h2>\n              <form onSubmit={handleSubmit} className=\"space-y-4\">\n                <div>\n                  <label\n                    htmlFor=\"title\"\n                    className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\"\n                  >\n                    Topic Title *\n                  </label>\n                  <input\n                    type=\"text\"\n                    id=\"title\"\n                    value={formData.title}\n                    onChange={(e) =>\n                      setFormData({ ...formData, title: e.target.value })\n                    }\n                    className=\"w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent dark:bg-gray-700 dark:border-gray-600 dark:text-white\"\n                    placeholder=\"Enter topic title\"\n                    required\n                  />\n                </div>\n                <div>\n                  <label\n                    htmlFor=\"description\"\n                    className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\"\n                  >\n                    Description\n                  </label>\n                  <textarea\n                    id=\"description\"\n                    value={formData.description}\n                    onChange={(e) =>\n                      setFormData({ ...formData, description: e.target.value })\n                    }\n                    rows={6}\n                    className=\"w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent dark:bg-gray-700 dark:border-gray-600 dark:text-white\"\n                    placeholder=\"Enter topic description\"\n                  />\n                </div>\n                <div>\n                  <label\n                    htmlFor=\"parentTopicId\"\n                    className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\"\n                  >\n                    Parent Topic (Optional)\n                  </label>\n                  <select\n                    id=\"parentTopicId\"\n                    value={formData.parentTopicId}\n                    onChange={(e) =>\n                      setFormData({ ...formData, parentTopicId: e.target.value })\n                    }\n                    className=\"w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent dark:bg-gray-700 dark:border-gray-600 dark:text-white\"\n                  >\n                    <option value=\"\">None (Root Topic)</option>\n                    {topics\n                      .filter(\n                        (t) =>\n                          t._id !== editingTopic?._id &&\n                          t._id !== formData.parentTopicId\n                      )\n                      .map((topic) => (\n                        <option key={topic._id} value={topic._id}>\n                          {topic.title}\n                        </option>\n                      ))}\n                  </select>\n                </div>\n                <div className=\"flex gap-4\">\n                  <button\n                    type=\"submit\"\n                    className=\"flex-1 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg transition-colors\"\n                  >\n                    {editingTopic ? \"Update Topic\" : \"Create Topic\"}\n                  </button>\n                  {editingTopic && (\n                    <button\n                      type=\"button\"\n                      onClick={handleCancel}\n                      className=\"flex-1 bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 px-4 rounded-lg transition-colors\"\n                    >\n                      Cancel\n                    </button>\n                  )}\n                </div>\n              </form>\n            </div>\n\n            {/* Selected Topic Details */}\n            {selectedTopic && !editingTopic && (\n              <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6\">\n                <div className=\"flex justify-between items-start mb-4\">\n                  <h2 className=\"text-2xl font-semibold text-gray-900 dark:text-white\">\n                    {selectedTopic.title}\n                  </h2>\n                  <div className=\"flex gap-2\">\n                    <button\n                      onClick={() => handleEdit(selectedTopic)}\n                      className=\"px-4 py-2 bg-yellow-500 hover:bg-yellow-600 text-white font-medium rounded-lg transition-colors\"\n                    >\n                      Edit\n                    </button>\n                    <button\n                      onClick={() => handleDelete(selectedTopic._id!)}\n                      className=\"px-4 py-2 bg-red-500 hover:bg-red-600 text-white font-medium rounded-lg transition-colors\"\n                    >\n                      Delete\n                    </button>\n                  </div>\n                </div>\n\n                <div className=\"mb-6\">\n                  <h3 className=\"text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n                    Description\n                  </h3>\n                  <p className=\"text-gray-900 dark:text-white whitespace-pre-wrap\">\n                    {selectedTopic.description || \"No description provided.\"}\n                  </p>\n                </div>\n\n                {/* Linked Topics */}\n                <div className=\"mb-6\">\n                  <h3 className=\"text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n                    Linked Topics\n                  </h3>\n                  {selectedTopic.linkedTopics && selectedTopic.linkedTopics.length > 0 ? (\n                    <div className=\"space-y-2\">\n                      {selectedTopic.linkedTopics.map((linkedId) => {\n                        const linkedTopic = topics.find((t) => t._id === linkedId);\n                        return linkedTopic ? (\n                          <div\n                            key={linkedId}\n                            className=\"flex items-center justify-between p-3 bg-gray-50 dark:bg-gray-700 rounded-lg\"\n                          >\n                            <span\n                              onClick={() => handleTopicClick(linkedId)}\n                              className=\"text-blue-600 dark:text-blue-400 cursor-pointer hover:underline\"\n                            >\n                              {linkedTopic.title}\n                            </span>\n                            <button\n                              onClick={() => handleUnlinkTopic(linkedId)}\n                              className=\"px-2 py-1 bg-red-500 hover:bg-red-600 text-white text-xs rounded transition-colors\"\n                            >\n                              Unlink\n                            </button>\n                          </div>\n                        ) : null;\n                      })}\n                    </div>\n                  ) : (\n                    <p className=\"text-gray-500 dark:text-gray-400\">\n                      No linked topics.\n                    </p>\n                  )}\n                </div>\n\n                {/* Link New Topic */}\n                <div>\n                  <h3 className=\"text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n                    Link to Another Topic\n                  </h3>\n                  <select\n                    onChange={(e) => {\n                      if (e.target.value) {\n                        handleLinkTopic(e.target.value);\n                        e.target.value = \"\";\n                      }\n                    }}\n                    className=\"w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent dark:bg-gray-700 dark:border-gray-600 dark:text-white\"\n                  >\n                    <option value=\"\">Select a topic to link...</option>\n                    {availableTopics\n                      .filter(\n                        (t) =>\n                          !selectedTopic.linkedTopics?.includes(t._id!) &&\n                          t._id !== selectedTopic._id\n                      )\n                      .map((topic) => (\n                        <option key={topic._id} value={topic._id}>\n                          {topic.title}\n                        </option>\n                      ))}\n                  </select>\n                </div>\n\n                {selectedTopic.createdAt && (\n                  <p className=\"text-xs text-gray-400 dark:text-gray-500 mt-4\">\n                    Created: {new Date(selectedTopic.createdAt).toLocaleString()}\n                  </p>\n                )}\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\n"],"names":[],"mappings":"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","debugId":null}}]
}